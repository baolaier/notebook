**回溯算法**

寻找数组的所有子集：

```cpp
void dfs(int index, vector<int>& nums, vector<int>& res) {
    vi.push_back(res);  // 将当前子集添加到结果中
    
    for (int x = index; x < n; x++) {
        res.push_back(nums[x]);  // 添加当前元素到当前子集
        dfs(x + 1, nums, res);  // 递归调用，继续添加后续元素
        res.pop_back();  // 回溯，移除最后添加的元素
    }
}
```

算法核心思想在于在每次遍历的过程中每当遍历到一个新的元素时，将之前的子集加上这个元素那么就获得了一个全新的子集，那么我们既然生成了一个全新的子集就首先要把他记录下来

```cpp
vi.push_back(res);  // 将当前子集添加到结果中
```

然后我们要想得到新子集

```cpp
res.push_back(nums[x]);  // 添加当前元素到当前子集得到新子集
```

我们可以通过递归的特点（可以想象递归就是能完成一个指定的功能，如同数学归纳法，我们只要确定起始条件和地递推条件），现在我们递归的功能就是给一个子集元素，将所有新生成的子集元素放到vi这个结果中，在最开始的时候我们的子集应该是空，这也恰好是我们当前遍历到的全部子集（因为刚开始集合内没有元素），那么就满足了起始条件。

那么我们下一步要遍历其他的子集元素，因为一个初始子集可能有很多子集元素，那么我们就要整个遍历`nums`数组，这是因为增加`nums`元素会产生新的子集，我们遍历整个数组相当于产生新的一圈子集，然后在这一圈子集中继续递归，也就是用新子集产生一个更新的子集放到结果中（记得我们定义的递归函数作用）

```cpp
dfs(x + 1, nums, res);  // 递归调用，继续添加后续元素
```

当然这样还是不够的，因为我们发现按理来说我们在利用旧子集遍历数组加入数据的生成新子集的过程中我们的旧子集不会发生变化，但是在递归中我们的旧子集res肯定会发生变化，其原因是我们在递归过程中会把当前子集添加到res中，所以我们要回溯保证res不会发生改变

```cpp
res.pop_back();  // 回溯，移除最后添加的元素
```

这是个有意思的算法

